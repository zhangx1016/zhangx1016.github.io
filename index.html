<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree V6 - Stronger Bloom</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #020502; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        /* 1. é¡¶éƒ¨è‰ºæœ¯å­— */
        #main-title {
            text-align: center;
            margin-top: 20px;
            font-family: 'Great Vibes', cursive;
            font-size: 5rem;
            /* é‡‘è‰²æ¸å˜å’Œè¾‰å…‰æ•ˆæœ */
            background: linear-gradient(to bottom, #cfc09f 22%, #634f2c 24%, #cfc09f 26%, #cfc09f 27%, #ffecb3 40%, #3a2c0f 78%); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            color: #fff; 
            filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.8));
            opacity: 0;
            animation: fadeIn 2s forwards 1s;
        }
        @keyframes fadeIn { to { opacity: 1; } }

        /* 2. å·¦ä¸‹è§’æ‘„åƒå¤´ä¸å…‰æ•ˆè½¨è¿¹ */
        #cam-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 240px; height: 180px;
            border: 2px solid #d4af37;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            background: #000;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
            pointer-events: auto;
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        #trail-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* 3. å³ä¸‹è§’æ§åˆ¶åŒº */
        #controls-area {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
            pointer-events: auto;
        }
        .btn {
            background: linear-gradient(135deg, #d4af37, #aa8a29);
            color: #051005; padding: 10px 24px; border: none; border-radius: 25px;
            font-weight: bold; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
            transition: 0.2s; font-size: 12px;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(212, 175, 55, 0.8); }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37; font-size: 20px; letter-spacing: 2px;
            transition: opacity 0.5s;
        }
        .hint-text {
            color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 5px;
            text-shadow: 0 0 5px black;
        }
        input[type="file"] { display: none; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="main-title">Merry Christmas</div>
        
        <div id="loading">æ­£åœ¨åŠ è½½é­”æ³•å¼•æ“...</div>

        <div id="cam-container">
            <video id="input-video" playsinline></video>
            <canvas id="trail-canvas"></canvas>
        </div>

        <div id="controls-area">
            <div class="hint-text">æ”¯æŒæ‰‹åŠ¿: æ¡æ‹³(èš), äº”æŒ‡å¼ å¼€(æ•£), æåˆ(æŠ“å–), æŒ¥æ‰‹(æ—‹è½¬)</div>
            
            <button class="btn" onclick="document.getElementById('music-input').click()">ğŸµ ä¸Šä¼ èƒŒæ™¯éŸ³ä¹</button>
            <input type="file" id="music-input" accept="audio/*">
            <audio id="bgm-player" loop></audio>

            <button class="btn" onclick="document.getElementById('photo-input').click()">ğŸ“· æ·»åŠ ç…§ç‰‡</button>
            <input type="file" id="photo-input" multiple accept="image/*">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- é…ç½® ---
        const CONFIG = {
            colors: { 
                green: 0x2F5A38, 
                gold: 0xFFD700, 
                red: 0xC41E3A, 
                emissiveGold: 0x995500 
            },
            particleCount: 1500,     
            emojiCount: 75,          
            treeHeight: 30,
            treeRadius: 12,
            scatterRadius: 35,
            emojis: ['ğŸ', 'ğŸ§¦', 'ğŸ””', 'â¤ï¸', 'ğŸ…', 'ğŸ‘”'] 
        };
        
        // éšæœºé¢œè‰²åˆ—è¡¨ï¼Œç”¨äº 3D ç²’å­
        const RANDOM_COLORS = [
            { color: CONFIG.colors.gold, emissive: CONFIG.colors.emissiveGold, intensity: 0.8 }, // å¢å¼ºå…‰æ•ˆ
            { color: CONFIG.colors.red, emissive: 0x550000, intensity: 0.5 },
            { color: CONFIG.colors.green, emissive: 0x003300, intensity: 0.3 }
        ];

        const state = {
            mode: 'TREE',
            handDetected: false,
            focusedPhotoIndex: -1,
            photos: [],
            particles: []
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020502, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 55);

        // --- ç¯å…‰ ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.3));
        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 1.5, 80);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 20);
        scene.add(dirLight);

        // --- åå¤„ç† (è¾‰å…‰åŠ å¼º) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 2.0; // è¿›ä¸€æ­¥åŠ å¼ºå…‰æ•ˆ
        bloomPass.radius = 0.6;
        composer.addPass(bloomPass);

        // --- è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºEmojiçº¹ç† ---
        function createEmojiTexture(emoji, color = 'white') {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '90px sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = color;
            ctx.fillText(emoji, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }
        
        // --- ç²’å­ç³»ç»Ÿæ„å»º (å°ºå¯¸æ”¾å¤§) ---
        
        // æ”¾å¤§å‡ ä½•ä½“åŸºç¡€å°ºå¯¸ (ä¹˜ä»¥ 2)
        const geometries = {
            sphere: new THREE.SphereGeometry(0.24, 8, 8),   // 0.12 -> 0.24
            box: new THREE.BoxGeometry(0.4, 0.4, 0.4),      // 0.2 -> 0.4
            tri: new THREE.TetrahedronGeometry(0.3),  // 0.15 -> 0.3
        };
        
        function createRandomMaterial() {
            const randomColor = RANDOM_COLORS[Math.floor(Math.random() * RANDOM_COLORS.length)];
            return new THREE.MeshStandardMaterial({ 
                color: randomColor.color, 
                metalness: 0.8, 
                roughness: 0.3,
                emissive: randomColor.emissive, 
                emissiveIntensity: randomColor.intensity
            });
        }

        const emojiMaterials = CONFIG.emojis.map(e => new THREE.SpriteMaterial({ 
            map: createEmojiTexture(e), 
            transparent: true 
        }));

        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        function initParticles() {
            let emojiCounter = 0;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                
                // 95% å‡ ç‡ç”Ÿæˆ 3D å‡ ä½•ä½“ï¼Œå¹¶éšæœºé€‰æ‹©æè´¨
                if (Math.random() < 0.95) {
                    let geometry;
                    const geoRand = Math.random();
                    if (geoRand < 0.33) {
                        geometry = geometries.sphere;
                    } else if (geoRand < 0.66) {
                        geometry = geometries.box;
                    } else {
                        geometry = geometries.tri;
                    }
                    mesh = new THREE.Mesh(geometry, createRandomMaterial());
                } 
                
                // ä»…åœ¨è®¡æ•°å…è®¸æ—¶ç”Ÿæˆ Emoji è£…é¥° (5%)
                if (!mesh && i < CONFIG.emojiCount) {
                    const matIndex = emojiCounter % emojiMaterials.length; 
                    mesh = new THREE.Sprite(emojiMaterials[matIndex]);
                    mesh.scale.set(1, 1, 1); // Emoji Sprite æ”¾å¤§
                    emojiCounter++;
                } else if (!mesh) {
                    // Fallback 
                    mesh = new THREE.Mesh(geometries.sphere, createRandomMaterial());
                }

                // Tree Pos (Spiral Cone)
                const y = (Math.random() - 0.5) * CONFIG.treeHeight;
                const normY = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                const r = CONFIG.treeRadius * (1 - normY) + 0.5;
                const angle = Math.random() * Math.PI * 2 * 6;
                
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );

                // Scatter Pos (Sphere)
                const sR = CONFIG.scatterRadius * Math.cbrt(Math.random());
                const sTheta = Math.random() * Math.PI * 2;
                const sPhi = Math.acos(2 * Math.random() - 1);
                const scatterPos = new THREE.Vector3(
                    sR * Math.sin(sPhi) * Math.cos(sTheta),
                    sR * Math.sin(sPhi) * Math.sin(sTheta),
                    sR * Math.cos(sPhi)
                );

                mesh.position.copy(treePos);
                if (mesh.type === 'Mesh') {
                    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                    // ç²’å­éšæœºç¼©æ”¾èŒƒå›´ä¹Ÿæ”¾å¤§ä¸€å€
                    mesh.scale.setScalar(Math.random() * 0.2 + 0.4); // 0.4 ~ 0.6
                }
                
                mesh.userData = {
                    treePos: treePos,
                    scatterPos: scatterPos,
                };

                particleGroup.add(mesh);
                state.particles.push(mesh);
            }
        }
        initParticles();


        // --- é¡¶éƒ¨é‡‘è‰²ç²’å­å…‰çƒ (å°ºå¯¸æ”¾å¤§) ---
        const starGeo = new THREE.SphereGeometry(0.7, 16, 16); // 0.35 -> 0.7
        const starMat = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.gold,
            metalness: 1.0,
            roughness: 0.1,
            emissive: CONFIG.colors.gold,
            emissiveIntensity: 6.0 // è¿›ä¸€æ­¥å¢å¼ºå…‰æ•ˆ
        });
        const treeStar = new THREE.Mesh(starGeo, starMat);
        treeStar.position.set(0, CONFIG.treeHeight / 2 + 1, 0);
        scene.add(treeStar);

        // --- ç…§ç‰‡ç³»ç»Ÿ (ä¿æŒä¸å˜) ---
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);

        function addPhoto(texture) {
            const aspect = texture.image.width / texture.image.height;
            const h = 5;
            const w = h * aspect;
            
            const geo = new THREE.PlaneGeometry(w, h);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);

            const border = new THREE.Mesh(
                new THREE.PlaneGeometry(w + 0.3, h + 0.3),
                new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1, roughness: 0.2 })
            );
            border.position.z = -0.02;
            mesh.add(border);

            const idx = state.photos.length;
            const angle = idx * 1.2;
            const r = 8;
            const treePos = new THREE.Vector3(Math.cos(angle)*r, -10 + idx*2.5, Math.sin(angle)*r);

            mesh.userData = {
                treePos: treePos,
                treeRot: new THREE.Euler(0, -angle + Math.PI/2, 0),
                scatterPos: new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*30, (Math.random()-0.5)*20),
                scatterRot: new THREE.Euler(Math.random(), Math.random(), 0)
            };

            mesh.position.copy(state.mode === 'TREE' ? mesh.userData.treePos : mesh.userData.scatterPos);
            mesh.rotation.copy(state.mode === 'TREE' ? mesh.userData.treeRot : mesh.userData.scatterRot);

            photoGroup.add(mesh);
            state.photos.push(mesh);
        }

        // --- æ ¸å¿ƒé€»è¾‘ä¸çŠ¶æ€åˆ‡æ¢ (ä¿æŒä¸å˜) ---
        function transitionTo(newMode) {
            if(state.mode === newMode) return;
            state.mode = newMode;
            
            const duration = 1.2;
            const ease = "power2.inOut";

            state.particles.forEach(p => {
                const target = newMode === 'TREE' ? p.userData.treePos : p.userData.scatterPos;
                gsap.to(p.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: duration + Math.random()*0.5,
                    ease: ease
                });
                if(p.type === 'Mesh') {
                    gsap.to(p.rotation, {
                        x: Math.random()*Math.PI, y: Math.random()*Math.PI,
                        duration: duration
                    });
                }
            });

            state.photos.forEach(p => {
                if(newMode === 'FOCUS') return;
                const tPos = newMode === 'TREE' ? p.userData.treePos : p.userData.scatterPos;
                const tRot = newMode === 'TREE' ? p.userData.treeRot : p.userData.scatterRot;
                
                gsap.to(p.position, { x: tPos.x, y: tPos.y, z: tPos.z, duration: duration, ease: ease });
                gsap.to(p.rotation, { x: tRot.x, y: tRot.y, z: tRot.z, duration: duration, ease: ease });
                gsap.to(p.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            });

            if(newMode === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 5, z: 55, duration: 1.5 });
                gsap.to(particleGroup.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });
                gsap.to(photoGroup.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });
            }
        }

        function focusPhoto() {
            if(!state.photos.length || state.mode === 'FOCUS') return;
            state.mode = 'FOCUS';
            
            state.focusedPhotoIndex = (state.focusedPhotoIndex + 1) % state.photos.length;
            const target = state.photos[state.focusedPhotoIndex];
            
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const dest = camera.position.clone().add(camDir.multiplyScalar(15));
            
            gsap.to(target.position, { x: dest.x, y: dest.y, z: dest.z, duration: 0.8, ease: "back.out(1.2)" });
            gsap.to(target.rotation, { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z, duration: 0.8 });
            gsap.to(target.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.8 });
        }

        // --- åª’ä½“è¾“å…¥ (éŸ³ä¹ & å›¾ç‰‡) ---
        document.getElementById('music-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                const player = document.getElementById('bgm-player');
                player.src = URL.createObjectURL(file);
                player.volume = 0.5;
                player.play();
            }
        });

        document.getElementById('photo-input').addEventListener('change', (e) => {
            const files = e.target.files;
            const loader = new THREE.TextureLoader();
            for(let f of files) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        addPhoto(tex);
                    }
                };
                reader.readAsDataURL(f);
            }
        });

        // --- æ‰‹åŠ¿è¯†åˆ« & 2Då…‰æ•ˆè½¨è¿¹ ---
        const videoElement = document.getElementById('input-video');
        const trailCanvas = document.getElementById('trail-canvas');
        const trailCtx = trailCanvas.getContext('2d');
        let trailPoints = [];

        function resizeTrailCanvas() {
            trailCanvas.width = videoElement.clientWidth;
            trailCanvas.height = videoElement.clientHeight;
        }

        function drawTrail(x, y) {
            trailPoints.push({ x, y, life: 1.0 });
            if(trailPoints.length > 20) trailPoints.shift();
            
            trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
            trailCtx.lineCap = 'round';
            trailCtx.lineJoin = 'round';

            if(trailPoints.length > 1) {
                trailCtx.beginPath();
                trailCtx.moveTo(trailPoints[0].x, trailPoints[0].y);
                for(let i=1; i<trailPoints.length; i++) {
                    trailCtx.lineTo(trailPoints[i].x, trailPoints[i].y);
                }
                trailCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                trailCtx.lineWidth = 4;
                trailCtx.shadowBlur = 10;
                trailCtx.shadowColor = '#FFD700';
                trailCtx.stroke();
            }
        }

        function onResults(results) {
            document.getElementById('loading').style.opacity = 0;
            if(!trailCanvas.width) resizeTrailCanvas();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                const tipX = landmarks[8].x * trailCanvas.width;
                const tipY = landmarks[8].y * trailCanvas.height;
                drawTrail(tipX, tipY);

                const fingersOpen = [8, 12, 16, 20].map(i => landmarks[i].y < landmarks[i-2].y);
                const openCount = fingersOpen.filter(Boolean).length;
                const isThumbOpen = landmarks[4].x < landmarks[3].x;
                const totalOpen = openCount + (isThumbOpen ? 1 : 0);

                const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                const isPinching = pinchDist < 0.08; 

                if (isPinching && state.mode === 'SCATTER') {
                    focusPhoto();
                } else if (totalOpen >= 4) {
                    if(state.mode !== 'SCATTER' && state.mode !== 'FOCUS') transitionTo('SCATTER');
                    if(state.mode === 'FOCUS' && !isPinching) transitionTo('SCATTER');
                } else if (totalOpen <= 1 && !isPinching) {
                    transitionTo('TREE');
                }

                if (state.mode === 'SCATTER') {
                    const palmX = landmarks[9].x; 
                    const palmY = landmarks[9].y;
                    
                    const rotX = (palmY - 0.5) * 4.0; 
                    const rotY = (palmX - 0.5) * 4.0;
                    
                    particleGroup.rotation.y += rotY * 0.02;
                    particleGroup.rotation.x += rotX * 0.02;
                    photoGroup.rotation.y += rotY * 0.02;
                    photoGroup.rotation.x += rotX * 0.02;
                }

            } else {
                state.handDetected = false;
                trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
                trailPoints = [];
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const camUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        camUtils.start();

        // --- æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            if(state.mode === 'TREE') {
                particleGroup.rotation.y += 0.003;
                photoGroup.rotation.y += 0.003;
            } else if (state.mode === 'SCATTER' && !state.handDetected) {
                particleGroup.rotation.y += 0.001;
            }
            
            // é¡¶éƒ¨å…‰çƒçš„å¾®å°ç¼©æ”¾åŠ¨ç”»
            const scaleFactor = 0.05 * Math.sin(Date.now() / 500) + 1.05;
            treeStar.scale.setScalar(scaleFactor);

            composer.render();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        window.addEventListener('resize', resizeTrailCanvas);

        animate();

    </script>
</body>
</html>
