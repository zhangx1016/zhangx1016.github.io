<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree V2</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #020502; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        /* 1. é¡¶éƒ¨è‰ºæœ¯å­— */
        #main-title {
            text-align: center;
            margin-top: 20px;
            font-family: 'Great Vibes', cursive;
            font-size: 5rem;
            background: linear-gradient(to bottom, #cfc09f 22%, #634f2c 24%, #cfc09f 26%, #cfc09f 27%, #ffecb3 40%, #3a2c0f 78%); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            color: #fff; 
            filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.8));
            opacity: 0;
            animation: fadeIn 2s forwards 1s;
        }

        @keyframes fadeIn { to { opacity: 1; } }

        /* 2. å·¦ä¸‹è§’æ‘„åƒå¤´ä¸å…‰æ•ˆè½¨è¿¹ */
        #cam-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 240px; height: 180px;
            border: 2px solid #d4af37;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            background: #000;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
            pointer-events: auto;
        }
        #input-video {
            width: 100%; height: 100%; object-fit: cover;
            opacity: 0.6; /* ç¨å¾®æš—ä¸€ç‚¹ï¼Œçªå‡ºå…‰æ•ˆ */
        }
        #trail-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }

        /* 3. å³ä¸‹è§’æ§åˆ¶åŒº */
        #controls-area {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
            pointer-events: auto;
        }

        .btn {
            background: linear-gradient(135deg, #d4af37, #aa8a29);
            color: #051005; padding: 10px 24px; border: none; border-radius: 25px;
            font-weight: bold; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
            transition: 0.2s; font-size: 12px;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(212, 175, 55, 0.8); }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37; font-size: 20px; letter-spacing: 2px;
            transition: opacity 0.5s;
        }
        
        .hint-text {
            color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 5px;
            text-shadow: 0 0 5px black;
        }

        input[type="file"] { display: none; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="main-title">Merry Christmas</div>
        
        <div id="loading">æ­£åœ¨åŠ è½½é­”æ³•å¼•æ“...</div>

        <div id="cam-container">
            <video id="input-video" playsinline></video>
            <canvas id="trail-canvas"></canvas>
        </div>

        <div id="controls-area">
            <div class="hint-text">æ”¯æŒæ‰‹åŠ¿: æ¡æ‹³(èš), äº”æŒ‡å¼ å¼€(æ•£), æåˆ(æŠ“å–), æŒ¥æ‰‹(æ—‹è½¬)</div>
            
            <button class="btn" onclick="document.getElementById('music-input').click()">ğŸµ ä¸Šä¼ èƒŒæ™¯éŸ³ä¹</button>
            <input type="file" id="music-input" accept="audio/*">
            <audio id="bgm-player" loop></audio>

            <button class="btn" onclick="document.getElementById('photo-input').click()">ğŸ“· æ·»åŠ ç…§ç‰‡</button>
            <input type="file" id="photo-input" multiple accept="image/*">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- é…ç½® ---
        const CONFIG = {
            colors: { green: 0x2F5A38, gold: 0xFFD700, red: 0xC41E3A, white: 0xFFFFFF },
            particleCount: 800, // æ€»ç²’å­æ•°
            treeHeight: 30,
            treeRadius: 12,
            scatterRadius: 35,
            emojis: ['ğŸ', 'ğŸ§¦', 'ğŸ””', 'ğŸ‘”', 'ğŸ…', 'â¤ï¸', 'ğŸŒ³', 'â›„'] // ç²’å­è´´å›¾åº“
        };

        const state = {
            mode: 'TREE',
            handDetected: false,
            focusedPhotoIndex: -1,
            photos: [],
            particles: [] // å­˜å‚¨æ‰€æœ‰æ··åˆç²’å­å¯¹è±¡
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020502, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 55);

        // --- ç¯å…‰ ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.3));
        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 1.5, 80);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 20);
        scene.add(dirLight);

        // --- åå¤„ç† (è¾‰å…‰) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.3;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºEmojiçº¹ç† ---
        function createEmojiTexture(emoji, color = 'white') {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '90px sans-serif'; // å¤§å­—ä½“ä»¥ä¿è¯æ¸…æ™°
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = color;
            ctx.fillText(emoji, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- ç²’å­ç³»ç»Ÿæ„å»º (æ··åˆå‡ ä½•ä½“ä¸Sprite) ---
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        const geometries = {
            box: new THREE.BoxGeometry(0.8, 0.8, 0.8),
            tri: new THREE.TetrahedronGeometry(0.6),
        };
        const materials = {
            gold: new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 0.9, roughness: 0.1 }),
            red: new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, metalness: 0.3, roughness: 0.4 }),
            green: new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.1, roughness: 0.8 })
        };

        // é¢„ç”Ÿæˆ Emoji æè´¨åº“
        const emojiMaterials = CONFIG.emojis.map(e => new THREE.SpriteMaterial({ 
            map: createEmojiTexture(e), 
            transparent: true 
        }));

        function initParticles() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                const typeRand = Math.random();

                // 30% å‡ ä½•ä½“, 70% Emoji
                if (typeRand < 0.15) {
                    mesh = new THREE.Mesh(geometries.box, Math.random() > 0.5 ? materials.gold : materials.red);
                } else if (typeRand < 0.3) {
                    mesh = new THREE.Mesh(geometries.tri, materials.gold);
                } else {
                    const matIndex = Math.floor(Math.random() * emojiMaterials.length);
                    mesh = new THREE.Sprite(emojiMaterials[matIndex]);
                    mesh.scale.set(2, 2, 2); // Spriteéœ€è¦å¤§ä¸€ç‚¹
                }

                // è®¡ç®—æ ‘å½¢ä½ç½® (èºæ—‹åœ†é”¥)
                const y = (Math.random() - 0.5) * CONFIG.treeHeight; // -H/2 ~ H/2
                const normY = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                const r = CONFIG.treeRadius * (1 - normY) + 1; // é¡¶éƒ¨æ”¶çª„
                const angle = Math.random() * Math.PI * 2 * 6; // å¤šåœˆèºæ—‹
                
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );

                // è®¡ç®—æ•£å¼€ä½ç½® (çƒå½¢åˆ†å¸ƒ)
                const sR = CONFIG.scatterRadius * Math.cbrt(Math.random());
                const sTheta = Math.random() * Math.PI * 2;
                const sPhi = Math.acos(2 * Math.random() - 1);
                const scatterPos = new THREE.Vector3(
                    sR * Math.sin(sPhi) * Math.cos(sTheta),
                    sR * Math.sin(sPhi) * Math.sin(sTheta),
                    sR * Math.cos(sPhi)
                );

                mesh.position.copy(treePos);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                
                mesh.userData = {
                    treePos: treePos,
                    scatterPos: scatterPos,
                    velocity: new THREE.Vector3(0,0,0) // æ¼‚æµ®ç”¨
                };

                particleGroup.add(mesh);
                state.particles.push(mesh);
            }
        }
        initParticles();

        // --- ç…§ç‰‡ç³»ç»Ÿ ---
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);

        function addPhoto(texture) {
            const aspect = texture.image.width / texture.image.height;
            const h = 5;
            const w = h * aspect;
            
            const geo = new THREE.PlaneGeometry(w, h);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);

            // é‡‘è‰²è¾¹æ¡†
            const border = new THREE.Mesh(
                new THREE.PlaneGeometry(w + 0.3, h + 0.3),
                new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1, roughness: 0.2 })
            );
            border.position.z = -0.02;
            mesh.add(border);

            const idx = state.photos.length;
            const angle = idx * 1.2;
            const r = 8;
            const treePos = new THREE.Vector3(Math.cos(angle)*r, -10 + idx*2.5, Math.sin(angle)*r);

            mesh.userData = {
                treePos: treePos,
                treeRot: new THREE.Euler(0, -angle + Math.PI/2, 0),
                scatterPos: new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*30, (Math.random()-0.5)*20),
                scatterRot: new THREE.Euler(Math.random(), Math.random(), 0)
            };

            mesh.position.copy(state.mode === 'TREE' ? mesh.userData.treePos : mesh.userData.scatterPos);
            mesh.rotation.copy(state.mode === 'TREE' ? mesh.userData.treeRot : mesh.userData.scatterRot);

            photoGroup.add(mesh);
            state.photos.push(mesh);
        }

        // --- æ ¸å¿ƒé€»è¾‘ä¸çŠ¶æ€åˆ‡æ¢ ---
        function transitionTo(newMode) {
            if(state.mode === newMode) return;
            state.mode = newMode;
            
            const duration = 1.2; // ç¨å¾®åŠ å¿«è¿‡æ¸¡
            const ease = "power2.inOut";

            // ç²’å­åŠ¨ç”»
            state.particles.forEach(p => {
                const target = newMode === 'TREE' ? p.userData.treePos : p.userData.scatterPos;
                gsap.to(p.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: duration + Math.random()*0.5,
                    ease: ease
                });
                if(p.type === 'Mesh') { // åªæœ‰å‡ ä½•ä½“æ—‹è½¬ï¼ŒSpriteæ€»æ˜¯é¢æœç›¸æœº
                    gsap.to(p.rotation, {
                        x: Math.random()*Math.PI, y: Math.random()*Math.PI,
                        duration: duration
                    });
                }
            });

            // ç…§ç‰‡åŠ¨ç”»
            state.photos.forEach(p => {
                if(newMode === 'FOCUS') return;
                const tPos = newMode === 'TREE' ? p.userData.treePos : p.userData.scatterPos;
                const tRot = newMode === 'TREE' ? p.userData.treeRot : p.userData.scatterRot;
                
                gsap.to(p.position, { x: tPos.x, y: tPos.y, z: tPos.z, duration: duration, ease: ease });
                gsap.to(p.rotation, { x: tRot.x, y: tRot.y, z: tRot.z, duration: duration, ease: ease });
                gsap.to(p.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            });

            // ç›¸æœºå¤ä½
            if(newMode === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 5, z: 55, duration: 1.5 });
                gsap.to(particleGroup.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });
                gsap.to(photoGroup.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });
            }
        }

        function focusPhoto() {
            if(!state.photos.length || state.mode === 'FOCUS') return;
            state.mode = 'FOCUS';
            
            state.focusedPhotoIndex = (state.focusedPhotoIndex + 1) % state.photos.length;
            const target = state.photos[state.focusedPhotoIndex];
            
            // å°†ç…§ç‰‡ç§»åˆ°ç›¸æœºå‰æ–¹
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const dest = camera.position.clone().add(camDir.multiplyScalar(15));
            
            gsap.to(target.position, { x: dest.x, y: dest.y, z: dest.z, duration: 0.8, ease: "back.out(1.2)" });
            gsap.to(target.rotation, { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z, duration: 0.8 });
            gsap.to(target.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.8 });
        }

        // --- åª’ä½“è¾“å…¥ (éŸ³ä¹ & å›¾ç‰‡) ---
        document.getElementById('music-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                const player = document.getElementById('bgm-player');
                player.src = URL.createObjectURL(file);
                player.volume = 0.5;
                player.play();
            }
        });

        document.getElementById('photo-input').addEventListener('change', (e) => {
            const files = e.target.files;
            const loader = new THREE.TextureLoader();
            for(let f of files) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        addPhoto(tex);
                    }
                };
                reader.readAsDataURL(f);
            }
        });

        // --- æ‰‹åŠ¿è¯†åˆ« & 2Då…‰æ•ˆè½¨è¿¹ ---
        const videoElement = document.getElementById('input-video');
        const trailCanvas = document.getElementById('trail-canvas');
        const trailCtx = trailCanvas.getContext('2d');
        let trailPoints = []; // å­˜å‚¨å…‰çº¿è·¯å¾„ç‚¹

        // è®¾ç½®Trail Canvaså°ºå¯¸
        function resizeTrailCanvas() {
            trailCanvas.width = videoElement.clientWidth;
            trailCanvas.height = videoElement.clientHeight;
        }
        window.addEventListener('resize', resizeTrailCanvas);

        function drawTrail(x, y) {
            trailPoints.push({ x, y, life: 1.0 });
            if(trailPoints.length > 20) trailPoints.shift();
            
            trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
            trailCtx.lineCap = 'round';
            trailCtx.lineJoin = 'round';

            // ç»˜åˆ¶é‡‘è‰²å…‰çº¿
            if(trailPoints.length > 1) {
                trailCtx.beginPath();
                trailCtx.moveTo(trailPoints[0].x, trailPoints[0].y);
                for(let i=1; i<trailPoints.length; i++) {
                    const p = trailPoints[i];
                    trailCtx.lineTo(p.x, p.y);
                }
                trailCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                trailCtx.lineWidth = 4;
                trailCtx.shadowBlur = 10;
                trailCtx.shadowColor = '#FFD700';
                trailCtx.stroke();
            }

            // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ (ç®€å•æ·¡å‡ºæ•ˆæœ)
            // è¿™é‡Œä¸ºäº†æ€§èƒ½ï¼Œæ¯å¸§åªç»˜åˆ¶æœ€æ–°çŠ¶æ€ï¼Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„ç²’å­é€»è¾‘
        }

        function onResults(results) {
            document.getElementById('loading').style.opacity = 0;
            if(!trailCanvas.width) resizeTrailCanvas();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. è·å–é£ŸæŒ‡æŒ‡å°– (Index Tip - 8) ç»˜åˆ¶è½¨è¿¹
                // MediaPipeåæ ‡æ˜¯å½’ä¸€åŒ–(0-1)ï¼Œéœ€è¦æ˜ å°„åˆ°canvaså°ºå¯¸
                const tipX = landmarks[8].x * trailCanvas.width;
                const tipY = landmarks[8].y * trailCanvas.height;
                drawTrail(tipX, tipY);

                // 2. äº¤äº’é€»è¾‘ä¼˜åŒ–
                // åˆ¤æ–­äº”æŒ‡å¼ å¼€ (æŒ‡å°– y < å…³èŠ‚ y - é˜ˆå€¼)
                const fingersOpen = [8, 12, 16, 20].map(i => landmarks[i].y < landmarks[i-2].y);
                const openCount = fingersOpen.filter(Boolean).length;
                const isThumbOpen = landmarks[4].x < landmarks[3].x; // ç®€å•çš„å³æ‰‹åˆ¤å®š
                const totalOpen = openCount + (isThumbOpen ? 1 : 0);

                // åˆ¤æ–­æåˆ (é£ŸæŒ‡8 ä¸ æ‹‡æŒ‡4 çš„è·ç¦»)
                const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                const isPinching = pinchDist < 0.08; // è°ƒé«˜é˜ˆå€¼ï¼Œæ›´å®¹æ˜“è§¦å‘

                // çŠ¶æ€æœº
                if (isPinching && state.mode === 'SCATTER') {
                    focusPhoto();
                } else if (totalOpen >= 4) {
                    if(state.mode !== 'SCATTER' && state.mode !== 'FOCUS') transitionTo('SCATTER');
                    if(state.mode === 'FOCUS' && !isPinching) transitionTo('SCATTER');
                } else if (totalOpen <= 1 && !isPinching) {
                    transitionTo('TREE');
                }

                // 3. æ—‹è½¬æ§åˆ¶ (çµæ•åº¦ä¼˜åŒ–)
                if (state.mode === 'SCATTER') {
                    const palmX = landmarks[9].x; 
                    const palmY = landmarks[9].y;
                    
                    // å¢åŠ ç³»æ•° 4.0ï¼Œè®©å°å¹…åº¦çš„æ‰‹éƒ¨ç§»åŠ¨äº§ç”Ÿæ˜æ˜¾çš„æ—‹è½¬
                    const rotX = (palmY - 0.5) * 4.0; 
                    const rotY = (palmX - 0.5) * 4.0;
                    
                    // æ–½åŠ æ—‹è½¬
                    particleGroup.rotation.y += rotY * 0.02;
                    particleGroup.rotation.x += rotX * 0.02;
                    photoGroup.rotation.y += rotY * 0.02;
                    photoGroup.rotation.x += rotX * 0.02;
                }

            } else {
                state.handDetected = false;
                trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
                trailPoints = [];
            }
        }

        // åˆå§‹åŒ–MediaPipe
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6, // é™ä½ä¸€ç‚¹ä»¥æé«˜è¿ç»­æ€§
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const camUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240 // é™ä½å¤„ç†åˆ†è¾¨ç‡ä»¥æé«˜æ€§èƒ½
        });
        camUtils.start();

        // --- æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // è‡ªåŠ¨å¾®æ—‹è½¬
            if(state.mode === 'TREE') {
                particleGroup.rotation.y += 0.003;
                photoGroup.rotation.y += 0.003;
            } else if (state.mode === 'SCATTER' && !state.handDetected) {
                // å¦‚æœæ•£å¼€ä¸”æ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œç¼“æ…¢æ¼‚æµ®
                particleGroup.rotation.y += 0.001;
            }

            composer.render();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
