<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020502; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            color: #d4af37; /* Metallic Gold */
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px; letter-spacing: 2px;
            transition: opacity 0.5s;
        }

        .controls-hint {
            font-size: 14px;
            background: rgba(0, 20, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #d4af37;
            max-width: 300px;
        }

        .controls-hint h3 { margin: 0 0 10px 0; font-weight: 300; text-transform: uppercase; }
        .controls-hint p { margin: 5px 0; display: flex; align-items: center; gap: 10px; }
        .icon { width: 20px; text-align: center; }

        /* Upload Button */
        #upload-container {
            pointer-events: auto;
            align-self: flex-end;
        }
        
        input[type="file"] { display: none; }
        .btn {
            background: linear-gradient(135deg, #d4af37, #aa8a29);
            color: #051005;
            padding: 12px 30px;
            border: none;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.7);
        }

        /* Video element for MediaPipe (Hidden) */
        #input-video { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>

    <video id="input-video"></video>

    <div id="ui-layer">
        <div class="controls-hint">
            <h3>Gesture Controls</h3>
            <p><span class="icon">‚úä</span> Êè°Êã≥: ËÅöÂêà (Âú£ËØûÊ†ë)</p>
            <p><span class="icon">üñêÔ∏è</span> Âº†ÂºÄ: Êï£ÂºÄ (ÊºÇÊµÆÊ®°Âºè)</p>
            <p><span class="icon">üëã</span> ÊóãËΩ¨: ÊâãÊéåÁßªÂä®ÊóãËΩ¨ËßÜËßí</p>
            <p><span class="icon">üëå</span> ÊçèÂêà: ÊäìÂèñ/Êü•ÁúãÁÖßÁâá</p>
        </div>
        <div id="loading">Initialize AI & Graphics...</div>
        <div id="upload-container">
            <button class="btn" onclick="document.getElementById('file-input').click()">+ Ê∑ªÂä†ÁÖßÁâá</button>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';
        // MediaPipe is loaded globally via script tags usually, but here we handle via dynamic import or global window access if CDN allows
        // Since MediaPipe standard CDN exports globals, we will use script injection for them to ensure compatibility
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- Configuration ---
        const CONFIG = {
            colors: {
                green: 0x2F5A38, // Matte Green
                gold: 0xFFD700,  // Metallic Gold
                red: 0x8B0000,   // Christmas Red
                bg: 0x020502
            },
            particleCount: 1500,
            treeHeight: 25,
            treeRadius: 10,
            scatterRadius: 30
        };

        // --- Global State ---
        const state = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            handDetected: false,
            rotation: { x: 0, y: 0 },
            photos: [], // Array of meshes
            particles: [], // Array of instanced mesh data
            focusedPhotoIndex: -1
        };

        // --- Three.js Setup ---
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // Strong cinematic glow
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Object Managers ---
        
        // 1. Decorative Particles (InstancedMesh)
        const geometrySphere = new THREE.SphereGeometry(0.3, 16, 16);
        const materialGold = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, 
            metalness: 0.9, 
            roughness: 0.1 
        });
        const materialGreen = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.green, 
            metalness: 0.1, 
            roughness: 0.8 
        });
        
        // Create mixed instances
        const instancedMeshGold = new THREE.InstancedMesh(geometrySphere, materialGold, CONFIG.particleCount / 2);
        const instancedMeshGreen = new THREE.InstancedMesh(geometrySphere, materialGreen, CONFIG.particleCount / 2);
        
        scene.add(instancedMeshGold);
        scene.add(instancedMeshGreen);

        const dummy = new THREE.Object3D();
        const particlesData = []; // Store targets

        function initParticles() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const isGold = i % 2 === 0;
                
                // Tree Form Calculation (Cone)
                const y = (Math.random() - 0.5) * CONFIG.treeHeight; // -H/2 to H/2
                const normalizedY = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight; // 0 to 1
                const radiusAtY = CONFIG.treeRadius * (1 - normalizedY);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radiusAtY;
                
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );

                // Scatter Form Calculation (Sphere)
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const scatterR = CONFIG.scatterRadius * Math.cbrt(Math.random()); // Even distribution inside sphere
                
                const scatterPos = new THREE.Vector3(
                    scatterR * Math.sin(phi) * Math.cos(theta),
                    scatterR * Math.sin(phi) * Math.sin(theta),
                    scatterR * Math.cos(phi)
                );

                particlesData.push({
                    mesh: isGold ? instancedMeshGold : instancedMeshGreen,
                    index: Math.floor(i/2),
                    treePos: treePos,
                    scatterPos: scatterPos,
                    currentPos: treePos.clone(),
                    scale: Math.random() * 0.5 + 0.5
                });
            }
            updateParticles();
        }

        function updateParticles() {
            particlesData.forEach(p => {
                dummy.position.copy(p.currentPos);
                dummy.scale.setScalar(p.scale);
                dummy.updateMatrix();
                p.mesh.setMatrixAt(p.index, dummy.matrix);
            });
            instancedMeshGold.instanceMatrix.needsUpdate = true;
            instancedMeshGreen.instanceMatrix.needsUpdate = true;
        }

        initParticles();

        // 2. Photo System
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);

        function createPhotoMesh(texture) {
            // Aspect ratio
            const aspect = texture.image.width / texture.image.height;
            const height = 4;
            const width = height * aspect;

            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Frame for the photo (Luxurious Gold Border)
            const borderGeo = new THREE.PlaneGeometry(width + 0.2, height + 0.2);
            const borderMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.05;
            mesh.add(border);

            // Assign Tree Position (Spiral)
            const idx = state.photos.length;
            const y = -10 + (idx * 2); // Simple spiral up
            const angle = idx * 1.5;
            const r = 6;
            
            mesh.userData = {
                treePos: new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r),
                treeRot: new THREE.Euler(0, -angle + Math.PI/2, 0), // Face outward
                scatterPos: new THREE.Vector3(
                    (Math.random()-0.5) * 30,
                    (Math.random()-0.5) * 20,
                    (Math.random()-0.5) * 20
                ),
                scatterRot: new THREE.Euler(Math.random(), Math.random(), 0),
                originalScale: 1
            };

            // Initialize at tree pos
            mesh.position.copy(mesh.userData.treePos);
            mesh.rotation.copy(mesh.userData.treeRot);
            
            photoGroup.add(mesh);
            state.photos.push(mesh);
            
            // If we are currently in scatter mode, animate this new photo to scatter immediately
            if(state.mode === 'SCATTER') {
                 gsap.to(mesh.position, {
                    x: mesh.userData.scatterPos.x,
                    y: mesh.userData.scatterPos.y,
                    z: mesh.userData.scatterPos.z,
                    duration: 1
                });
                gsap.to(mesh.rotation, {
                    x: mesh.userData.scatterRot.x,
                    y: mesh.userData.scatterRot.y,
                    z: mesh.userData.scatterRot.z,
                    duration: 1
                });
            }
        }

        // Handle File Upload
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;

            const loader = new THREE.TextureLoader();
            for(let i=0; i<files.length; i++) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                       const texture = new THREE.Texture(img);
                       texture.needsUpdate = true;
                       texture.colorSpace = THREE.SRGBColorSpace;
                       createPhotoMesh(texture);
                    };
                };
                reader.readAsDataURL(files[i]);
            }
        });

        // --- Logic & Transitions ---

        function transitionTo(newMode) {
            if(state.mode === newMode) return;
            state.mode = newMode;
            console.log("Mode Switch:", newMode);

            const duration = 1.5;
            const ease = "power2.inOut";

            // 1. Animate Particles
            particlesData.forEach(p => {
                const target = (newMode === 'TREE') ? p.treePos : p.scatterPos;
                gsap.to(p.currentPos, {
                    x: target.x,
                    y: target.y,
                    z: target.z,
                    duration: duration + Math.random(), // Random delay
                    ease: ease,
                    onUpdate: () => {
                        // We update the instanced mesh in the render loop based on currentPos
                    }
                });
            });

            // 2. Animate Photos
            state.photos.forEach(mesh => {
                if (newMode === 'FOCUS') return; // Handled separately

                const targetPos = (newMode === 'TREE') ? mesh.userData.treePos : mesh.userData.scatterPos;
                const targetRot = (newMode === 'TREE') ? mesh.userData.treeRot : mesh.userData.scatterRot;

                gsap.to(mesh.position, {
                    x: targetPos.x, y: targetPos.y, z: targetPos.z,
                    duration: duration, ease: ease
                });
                gsap.to(mesh.rotation, {
                    x: targetRot.x, y: targetRot.y, z: targetRot.z,
                    duration: duration, ease: ease
                });
                gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 0.5 }); // Reset zoom
            });
            
            // Camera Reset if going back to tree
            if(newMode === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 0, z: 50, duration: 2 });
                gsap.to(photoGroup.rotation, { x: 0, y: 0, z: 0, duration: 2 });
                gsap.to(instancedMeshGold.rotation, { x: 0, y: 0, z: 0, duration: 2 });
                gsap.to(instancedMeshGreen.rotation, { x: 0, y: 0, z: 0, duration: 2 });
            }
        }

        function focusOnRandomPhoto() {
            if (state.photos.length === 0) return;
            if (state.mode === 'FOCUS') return; // Already focused
            state.mode = 'FOCUS';

            // Pick next photo or random
            state.focusedPhotoIndex = (state.focusedPhotoIndex + 1) % state.photos.length;
            const targetMesh = state.photos[state.focusedPhotoIndex];

            // Bring photo to front center
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const targetPos = camera.position.clone().add(camDir.multiplyScalar(15)); // 15 units in front of cam

            gsap.to(targetMesh.position, {
                x: targetPos.x, y: targetPos.y, z: targetPos.z,
                duration: 1, ease: "back.out(1.7)"
            });
            
            // Make it face camera
            gsap.to(targetMesh.rotation, {
                x: camera.rotation.x,
                y: camera.rotation.y,
                z: camera.rotation.z,
                duration: 1
            });

            gsap.to(targetMesh.scale, { x: 2, y: 2, z: 2, duration: 1 });
        }


        // --- MediaPipe Hands Logic ---
        
        const videoElement = document.getElementById('input-video');
        
        function onResults(results) {
            document.getElementById('loading').style.opacity = 0;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Gesture Recognition
                
                // Finger Tips vs PIP (Proximal Interphalangeal Joint) to detect open/close
                const isThumbOpen = landmarks[4].x < landmarks[3].x; // Simple check for right hand (adjust logic for robust universality)
                // Better robust check: Is tip above PIP?
                const fingersOpen = [8, 12, 16, 20].map(tip => {
                    return landmarks[tip].y < landmarks[tip - 2].y; // Note: Y is inverted in MediaPipe (0 is top)
                });
                
                const openCount = fingersOpen.filter(Boolean).length;
                
                // Pinch Detection (Index tip near Thumb tip)
                const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                const isPinching = pinchDist < 0.05;

                // State Machine Triggers
                if (isPinching && state.mode === 'SCATTER') {
                    // Trigger Grab/Focus
                    // Debounce slightly needed in real app, but here just trigger
                     focusOnRandomPhoto();
                } else if (openCount >= 4) {
                    // Open Hand -> Scatter
                    if(state.mode !== 'SCATTER' && state.mode !== 'FOCUS') transitionTo('SCATTER');
                    // If in Focus and open hand, go back to scatter
                    if(state.mode === 'FOCUS' && !isPinching) transitionTo('SCATTER');
                } else if (openCount <= 1 && !isPinching) {
                    // Fist -> Tree
                    transitionTo('TREE');
                }

                // 2. Rotation Control (Only in Scatter Mode)
                if (state.mode === 'SCATTER') {
                    // Map palm center (9) to rotation
                    const palmX = landmarks[9].x; // 0 to 1
                    const palmY = landmarks[9].y; // 0 to 1
                    
                    // Smooth lerp
                    const targetRotX = (palmY - 0.5) * 2; // -1 to 1
                    const targetRotY = (palmX - 0.5) * 2; // -1 to 1
                    
                    // Rotate the groups
                    photoGroup.rotation.y += (targetRotY * 0.05);
                    photoGroup.rotation.x += (targetRotX * 0.05);
                    
                    instancedMeshGold.rotation.y += (targetRotY * 0.05);
                    instancedMeshGold.rotation.x += (targetRotX * 0.05);
                    instancedMeshGreen.rotation.y += (targetRotY * 0.05);
                    instancedMeshGreen.rotation.x += (targetRotX * 0.05);
                }

            } else {
                state.handDetected = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Passive animation for "floating" effect
            if(state.mode === 'SCATTER' || state.mode === 'FOCUS') {
                photoGroup.rotation.y += 0.001;
                instancedMeshGold.rotation.y += 0.001;
                instancedMeshGreen.rotation.y += 0.001;
            } else {
                // Tree spinning slowly
                const spin = 0.005;
                photoGroup.rotation.y += spin;
                instancedMeshGold.rotation.y += spin;
                instancedMeshGreen.rotation.y += spin;
            }

            // Update Particle Positions (GSAP updates the objects, we need to update instance matrix)
            updateParticles();

            // Render
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
